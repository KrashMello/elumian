"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schema = exports.options = void 0;
exports.options = {
    varchar: (length = 255) => {
        return `varchar(${length})`;
    },
    smallInt: 'SMALLINT',
    bigInt: 'BIGINT',
    text: 'TEXT',
    pk: 'PRIMARY KEY',
    increment: 'GENERATED BY DEFAULT AS IDENTITY',
    unique: 'UNIQUE',
    notNull: 'NOT NULL',
    boolean: 'BOOLEAN',
    bool: 'BOOL',
    timeStamp: 'TIMESTAMP',
    ref: (type, tables) => {
        const [schema, table, column] = tables.split('.');
        switch (type) {
            case '>':
                return `ALTER TABLE "<schemaRef>"."<tableRef>" ADD FOREIGN KEY ("<columnRef>") REFERENCES "${schema}"."${table}" ("${column}");`;
            case '<':
                return `ALTER TABLE "${schema}"."${table}"  ADD FOREIGN KEY ("${column}") REFERENCES "<schemaRef>"."<tableRef>" ("<columnRef>");`;
            case '-':
                return `ALTER TABLE "<schemaRef>"."<tableRef>" ADD FOREIGN KEY ("<columnRef>") REFERENCES "${schema}"."${table}" ("${column}");`;
            default:
                return '';
        }
    },
};
class Schema {
    makeProceduresQuery(schemaName, procedures = null) {
        if (procedures == null)
            return '';
        const procedureName = Object.keys(procedures);
        return procedureName
            .map((v) => {
            var _a;
            const procedure = (_a = procedures[v]) !== null && _a !== void 0 ? _a : null;
            if (procedure == null)
                return '';
            let parametersKeyIn = [];
            let parametersKeyOut = [];
            let parametersKey;
            let declareKey;
            const fieldsIn = procedure.parameters.in;
            const fieldsOut = procedure.parameters.out;
            parametersKeyIn = Object.keys(fieldsIn);
            parametersKey = parametersKeyIn.map((z) => {
                var _a;
                const field = (_a = fieldsIn[z]) !== null && _a !== void 0 ? _a : null;
                if (field == null)
                    return '';
                return `${z}#23${field.replace(/\s/g, '#23')}`;
            });
            if (fieldsOut != null) {
                parametersKeyOut = Object.keys(fieldsOut);
                parametersKey = [
                    ...parametersKey,
                    ...parametersKeyOut.map((z) => {
                        var _a;
                        const field = (_a = fieldsOut[z]) !== null && _a !== void 0 ? _a : null;
                        if (field == null)
                            return '';
                        return `${z}#23${field.replace(/\s/g, '#23')}`;
                    }),
                ];
            }
            const declares = procedure.declare;
            if (declares != null) {
                declareKey = Object.keys(declares);
                declareKey = declareKey.map((z) => {
                    var _a;
                    const declare = (_a = declares[z]) !== null && _a !== void 0 ? _a : null;
                    if (declare == null)
                        return '';
                    return z + '#23' + declare.replace(/\s/g, '#23') + ';';
                });
            }
            const result = `
          create#23or#23replace#23procedure#23"${schemaName}"."${v}"(${parametersKey
                .toString()
                .replace(/,/g, '#24')})
          #23language#23plpgsql
          #23as#23$$#23
          #23declare#23
          ${declareKey != null ? declareKey.toString() : ''}
          #23begin#23
          ${procedure.comantBlock
                .replace(/(\s)\1/g, '#23')
                .replace(/\s/g, '#23')
                .replace(/,/g, '#24')}
          end;#23$$;
          `;
            return result.replace(/(#23)/g, ' ');
        })
            .toString()
            .replace(/,/g, '')
            .replace(/(#24)/g, ',');
    }
    makeFunctionsQuery(schemaName, functions) {
        if (functions == null)
            return '';
        const functionsName = Object.keys(functions);
        return functionsName
            .map((v) => {
            var _a, _b, _c;
            let parametersKey = [];
            let declareKey;
            const functionOne = (_a = functions[v]) !== null && _a !== void 0 ? _a : null;
            if (functionOne == null)
                return '';
            const parameters = (_b = functionOne.parameters) !== null && _b !== void 0 ? _b : null;
            parametersKey = Object.keys(functionOne.parameters);
            parametersKey = parametersKey.map((z) => {
                var _a;
                const parameter = (_a = parameters[z]) !== null && _a !== void 0 ? _a : null;
                if (parameter == null)
                    return '';
                return `${z}#23${parameter.replace(/\s/g, '#23')}`;
            });
            const declares = (_c = functionOne.declare) !== null && _c !== void 0 ? _c : null;
            if (declares != null) {
                declareKey = Object.keys(declares);
                declareKey = declareKey.map((z) => {
                    var _a;
                    const declare = (_a = declares[z]) !== null && _a !== void 0 ? _a : null;
                    if (declare == null)
                        return '';
                    return z + '#23' + declare.replace(/\s/g, '#23') + ';#23';
                });
            }
            const result = `
          create#23or#23replace#23function#23"${schemaName}"."${v}"(${parametersKey
                .toString()
                .replace(/,/g, '#24')})#23
          Returns#23${functionOne.return}#23
          #23language#23plpgsql
          #23as#23$$#23
          #23declare#23
          ${declareKey != null ? declareKey.toString() : ''}
          #23begin#23
          ${functionOne.comantBlock
                .replace(/(\s)\1/g, '#23')
                .replace(/\s/g, '#23')
                .replace(/,/g, '#24')}
          end;#23$$;

          `;
            return result.replace(/(#23)/g, ' ');
        })
            .toString()
            .replace(/,/g, '')
            .replace(/(#24)/g, ',');
    }
    makeTablesQuery(schemaName, tables, ref) {
        const tablesName = Object.keys(tables);
        return tablesName
            .map((key) => {
            var _a;
            const table = (_a = tables[key]) !== null && _a !== void 0 ? _a : null;
            if (table == null)
                return '';
            const columnsName = Object.keys(table);
            const columns = columnsName
                .map((name) => {
                var _a;
                let parameters = (_a = table[name]) !== null && _a !== void 0 ? _a : null;
                if (parameters == null)
                    return '';
                if (parameters.filter((v) => v.includes('ALTER TABLE ')).length > 0) {
                    ref.push(parameters
                        .filter((v) => v.includes('ALTER TABLE '))
                        .map((v) => {
                        return v
                            .replace(/<schemaRef>/g, schemaName)
                            .replace(/<tableRef>/g, key)
                            .replace(/<columnRef>/g, name);
                    })
                        .toString());
                }
                parameters = parameters.filter((v) => !v.includes('ALTER TABLE'));
                return `"${name}" ${parameters.toString().replace(/,/g, ' ')}\\`;
            })
                .toString()
                .replace(/,/g, '\n');
            return `CREATE TABLE IF NOT EXISTS "${schemaName}"."${key}" (
      ${columns}
      "created_at" timestamp default 'now()'\\
      "updated_at" timestamp default 'now()'
      );`;
        })
            .toString()
            .replace(/,/g, '')
            .replace(/(\\)|(,\s)/g, ',');
    }
    create(schemaName, tables, procedures = null, functions = null) {
        const ref = [];
        const query = {
            schema: `CREATE SCHEMA IF NOT EXISTS "${schemaName}";`,
            tables: `${this.makeTablesQuery(schemaName, tables, ref)}`.replace(/(\s{2,})/g, ''),
            ref: ref.toString().replace(/,/g, ''),
            procedures: this.makeProceduresQuery(schemaName, procedures),
            functions: this.makeFunctionsQuery(schemaName, functions),
        };
        return query;
    }
    drop(schemaName, tables) {
        return {
            schema: `${schemaName !== 'public'
                ? 'DROP SCHEMA "' + schemaName + '" CASCADE;'
                : ''}`,
            tables: tables
                .map((tableName) => {
                return `DROP TABLE IF EXISTS "${schemaName}"."${tableName}" CASCADE;`;
            })
                .toString()
                .replace(/,/g, '')
                .replace(/(\\)|(,\s)/g, ','),
        };
    }
}
exports.Schema = Schema;
//# sourceMappingURL=schema.js.map