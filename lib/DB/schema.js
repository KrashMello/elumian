"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schema = exports.options = void 0;
exports.options = {
    varchar: (length = 255) => {
        return `varchar(${length})`;
    },
    smallInt: 'SMALLINT',
    bigInt: 'BIGINT',
    text: 'TEXT',
    pk: 'PRIMARY KEY',
    increment: 'GENERATED BY DEFAULT AS IDENTITY',
    unique: 'UNIQUE',
    notNull: 'NOT NULL',
    boolean: 'BOOLEAN',
    bool: 'BOOL',
    timeStamp: 'TIMESTAMP',
    ref: (type, tables) => {
        const [schema, table, column] = tables.split('.');
        switch (type) {
            case '>':
                return `ALTER TABLE "<schemaRef>"."<tableRef>" ADD FOREIGN KEY ("<columnRef>") REFERENCES "${schema}"."${table}" ("${column}");`;
            case '<':
                return `ALTER TABLE "${schema}"."${table}"  ADD FOREIGN KEY ("${column}") REFERENCES "<schemaRef>"."<tableRef>" ("<columnRef>");`;
            case '-':
                return `ALTER TABLE "<schemaRef>"."<tableRef>" ADD FOREIGN KEY ("<columnRef>") REFERENCES "${schema}"."${table}" ("${column}");`;
            default:
                return '';
        }
    },
};
class Schema {
    makeProceduresQuery(schemaName, procedures = null) {
        if (procedures == null)
            return '';
        const procedureName = Object.keys(procedures);
        return procedureName
            .map((v) => {
            const procedure = procedures[v] ?? null;
            if (procedure == null)
                return '';
            let parametersKeyIn = [];
            let parametersKeyOut = [];
            let parametersKey;
            let declareKey;
            const fieldsIn = procedure.parameters.in;
            const fieldsOut = procedure.parameters.out;
            parametersKeyIn = Object.keys(fieldsIn);
            parametersKey = parametersKeyIn.map((z) => {
                const field = fieldsIn[z] ?? null;
                if (field == null)
                    return '';
                return `${z}#23${field.replace(/\s/g, '#23')}`;
            });
            if (fieldsOut != null) {
                parametersKeyOut = Object.keys(fieldsOut);
                parametersKey = [
                    ...parametersKey,
                    ...parametersKeyOut.map((z) => {
                        const field = fieldsOut[z] ?? null;
                        if (field == null)
                            return '';
                        return `${z}#23${field.replace(/\s/g, '#23')}`;
                    }),
                ];
            }
            const declares = procedure.declare;
            if (declares != null) {
                declareKey = Object.keys(declares);
                declareKey = declareKey.map((z) => {
                    const declare = declares[z] ?? null;
                    if (declare == null)
                        return '';
                    return z + '#23' + declare.replace(/\s/g, '#23') + ';';
                });
            }
            const result = `
          create#23or#23replace#23procedure#23"${schemaName}"."${v}"(${parametersKey
                .toString()
                .replace(/,/g, '#24')})
          #23language#23plpgsql
          #23as#23$$#23
          #23declare#23
          ${declareKey != null ? declareKey.toString() : ''}
          #23begin#23
          ${procedure.comantBlock
                .replace(/(\s)\1/g, '#23')
                .replace(/\s/g, '#23')
                .replace(/,/g, '#24')}
          end;#23$$;
          `;
            return result.replace(/(#23)/g, ' ');
        })
            .toString()
            .replace(/,/g, '')
            .replace(/(#24)/g, ',');
    }
    makeFunctionsQuery(schemaName, functions) {
        if (functions == null)
            return '';
        const functionsName = Object.keys(functions);
        return functionsName
            .map((v) => {
            let parametersKey = [];
            let declareKey;
            const functionOne = functions[v] ?? null;
            if (functionOne == null)
                return '';
            const parameters = functionOne.parameters ?? null;
            parametersKey = Object.keys(functionOne.parameters);
            parametersKey = parametersKey.map((z) => {
                const parameter = parameters[z] ?? null;
                if (parameter == null)
                    return '';
                return `${z}#23${parameter.replace(/\s/g, '#23')}`;
            });
            const declares = functionOne.declare ?? null;
            if (declares != null) {
                declareKey = Object.keys(declares);
                declareKey = declareKey.map((z) => {
                    const declare = declares[z] ?? null;
                    if (declare == null)
                        return '';
                    return z + '#23' + declare.replace(/\s/g, '#23') + ';#23';
                });
            }
            const result = `
          create#23or#23replace#23function#23"${schemaName}"."${v}"(${parametersKey
                .toString()
                .replace(/,/g, '#24')})#23
          Returns#23${functionOne.return}#23
          #23language#23plpgsql
          #23as#23$$#23
          #23declare#23
          ${declareKey != null ? declareKey.toString() : ''}
          #23begin#23
          ${functionOne.comantBlock
                .replace(/(\s)\1/g, '#23')
                .replace(/\s/g, '#23')
                .replace(/,/g, '#24')}
          end;#23$$;

          `;
            return result.replace(/(#23)/g, ' ');
        })
            .toString()
            .replace(/,/g, '')
            .replace(/(#24)/g, ',');
    }
    makeTablesQuery(schemaName, tables, ref) {
        const tablesName = Object.keys(tables);
        return tablesName
            .map((key) => {
            const table = tables[key] ?? null;
            if (table == null)
                return '';
            const columnsName = Object.keys(table);
            const columns = columnsName
                .map((name) => {
                let parameters = table[name] ?? null;
                if (parameters == null)
                    return '';
                if (parameters.filter((v) => v.includes('ALTER TABLE ')).length > 0) {
                    ref.push(parameters
                        .filter((v) => v.includes('ALTER TABLE '))
                        .map((v) => {
                        return v
                            .replace(/<schemaRef>/g, schemaName)
                            .replace(/<tableRef>/g, key)
                            .replace(/<columnRef>/g, name);
                    })
                        .toString());
                }
                parameters = parameters.filter((v) => !v.includes('ALTER TABLE'));
                return `"${name}" ${parameters.toString().replace(/,/g, ' ')}\\`;
            })
                .toString()
                .replace(/,/g, '\n');
            return `CREATE TABLE IF NOT EXISTS "${schemaName}"."${key}" (
      ${columns}
      "created_at" timestamp default 'now()'\\
      "updated_at" timestamp default 'now()'
      );`;
        })
            .toString()
            .replace(/,/g, '')
            .replace(/(\\)|(,\s)/g, ',');
    }
    create(schemaName, tables, procedures = null, functions = null) {
        const ref = [];
        const query = {
            schema: `CREATE SCHEMA IF NOT EXISTS "${schemaName}";`,
            tables: `${this.makeTablesQuery(schemaName, tables, ref)}`.replace(/(\s{2,})/g, ''),
            ref: ref.toString().replace(/,/g, ''),
            procedures: this.makeProceduresQuery(schemaName, procedures),
            functions: this.makeFunctionsQuery(schemaName, functions),
        };
        return query;
    }
    drop(schemaName, tables) {
        return {
            schema: `${schemaName !== 'public'
                ? 'DROP SCHEMA "' + schemaName + '" CASCADE;'
                : ''}`,
            tables: tables
                .map((tableName) => {
                return `DROP TABLE IF EXISTS "${schemaName}"."${tableName}" CASCADE;`;
            })
                .toString()
                .replace(/,/g, '')
                .replace(/(\\)|(,\s)/g, ','),
        };
    }
}
exports.Schema = Schema;
