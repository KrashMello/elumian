import type {
  schemaTables,
  options as optionsType,
  retrunVarchar,
  schemaUp,
  schemaDown,
  returnRef,
  typeRef,
  tablesRef,
  columnsPropiety,
  schemaFunctions,
  schemaProcedure,
} from './type'

export const options: optionsType = {
  varchar: (length: number = 255): retrunVarchar => {
    return `varchar(${length})`
  },
  smallInt: 'SMALLINT',
  bigInt: 'BIGINT',
  text: 'TEXT',
  pk: 'PRIMARY KEY',
  increment: 'GENERATED BY DEFAULT AS IDENTITY',
  unique: 'UNIQUE',
  notNull: 'NOT NULL',
  boolean: 'BOOLEAN',
  bool: 'BOOL',
  timeStamp: 'TIMESTAMP',
  ref: (type: typeRef, tables: tablesRef): returnRef => {
    const [schema, table, column] = tables.split('.') as [
      string,
      string,
      string
    ]

    switch (type) {
      case '>':
        return `ALTER TABLE "<schemaRef>"."<tableRef>" ADD FOREIGN KEY ("<columnRef>") REFERENCES "${schema}"."${table}" ("${column}");`
      case '<':
        return `ALTER TABLE "${schema}"."${table}"  ADD FOREIGN KEY ("${column}") REFERENCES "<schemaRef>"."<tableRef>" ("<columnRef>");`
      case '-':
        return `ALTER TABLE "<schemaRef>"."<tableRef>" ADD FOREIGN KEY ("<columnRef>") REFERENCES "${schema}"."${table}" ("${column}");`
      default:
        return ''
    }
  }
}

export class Schema {
  public create(schemaName: string, tables: schemaTables, procedures: schemaProcedure = null, functions: schemaFunctions = null): schemaUp {
    const tablesName: string[] = Object.keys(tables)
    let procedureName: string[]
    const ref: string[] = []
    let proceduresArrays: string[] = []
    if (procedures != null) {
      procedureName = Object.keys(procedures)
      proceduresArrays = procedureName.map((v) => {
        let parametersKeyIn: string[] = []
        let parametersKeyOut: string[] = []
        let parametersKey
        const fieldsIn = procedures[v].parameters.in
        const fieldsOut = procedures[v].parameters.out

        if (fieldsIn != null)
          parametersKeyIn = Object.keys(fieldsIn)
        if (fieldsOut != null)
          parametersKeyOut = Object.keys(fieldsOut)
        let declareKey
        parametersKey = parametersKeyIn.map((z) => {
          return `${z}#23${fieldsIn[z].replace(/\s/g, "#23")}`
        })
        parametersKey = [...parametersKey, ...parametersKeyOut.map((z) => {
          return `${z}#23${fieldsIn[z].replace(/\s/g, "#23")}`
        })
        ]
        if (procedures[v].declare != null) {
          declareKey = Object.keys(procedures[v].declare)
          declareKey = declareKey.map((z) => {
            return z + "#23" + procedures[v].declare[z].replace(/\s/g, "#23") + ";"
          })
        }
        const result = `
          create#23or#23replace#23procedure#23"${schemaName}"."${v}"(${parametersKey.toString().replace(/,/g, "#24")})
          #23language#23plpgsql
          #23as#23$$#23
          #23declare#23
          ${declareKey != null ? declareKey.toString() : ''}
          #23begin#23
          ${procedures[v].comantBlock.replace(/(\s)\1/g, "#23").replace(/\s/g, "#23").replace(/,/g, "#24")}
          end;#23$$;
          `
        return result.replace(/(#23)/g, " ")
      })
    }
    let functionsName: string[]
    const functionsArrays: string[] = []
    if (functions != null) {
      functionsName = Object.keys(functions)
      functionsArrays = functionsName.map((v) => {
        let parametersKey: string[] = []

        parametersKey = Object.keys(functions[v].parameters)
        let declareKey
        parametersKey = parametersKey.map((z) => {
          return `${z}#23${functions[v].parameters[z].replace(/\s/g, "#23")}`
        })
        if (procedures[v].declare != null) {
          declareKey = Object.keys(procedures[v].declare)
          declareKey = declareKey.map((z) => {
            return z + "#23" + procedures[v].declare[z].replace(/\s/g, "#23") + ";"
          })
        }
        const result = `
          create#23or#23replace#23function#23"${v}"(${declarekey})
          #23language#23plpgsql
          #23as
          ${functions[v].comantBlock.replace(/(\s)\1/g, "#23").replace(/\s/g, "#23")}
          `
        return result.replace(/(#23)/g, " ")
      })
    }

    const valuesColumns: string[] = tablesName.map((key) => {
      return `CREATE TABLE IF NOT EXISTS "${schemaName}"."${key}" (
      ${Object.keys(tables[key] as Record<string, columnsPropiety[]>)
          .map((columns) => {
            const table: Record<string, columnsPropiety[]> = tables[
              key
            ] as Record<string, columnsPropiety[]>
            let column: columnsPropiety[] = table[columns]
            if (column.filter((v) => v.includes('ALTER TABLE ')).length > 0) {
              ref.push(
                column
                  .filter((v) => v.includes('ALTER TABLE '))
                  .map((v) => {
                    return v
                      .replace(/<schemaRef>/g, schemaName)
                      .replace(/<tableRef>/g, key)
                      .replace(/<columnRef>/g, columns)
                  })
                  .toString()
              )
            }
            column = column.filter((v) => !v.includes('ALTER TABLE'))
            return `"${columns}" ${column.toString().replace(/,/g, ' ')}\\`
          })
          .toString()
          .replace(/,/g, '\n')}
      "created_at" timestamp default 'now()'\\
      "updated_at" timestamp default 'now()'
      );`
    })



    const query = {
      schema: `CREATE SCHEMA IF NOT EXISTS "${schemaName}";`,
      tables: `${valuesColumns
        .toString()
        .replace(/,/g, '')
        .replace(/(\\)|(,\s)/g, ',')}`.replace(/(\s{2,})/g, ''),
      ref: ref.toString().replace(/,/g, ''),
      procedures: proceduresArrays.toString().replace(/,/g, '').replace(/(#24)/g, ",")
    }
    return query
  }

  public drop(schemaName: string, tables: string[]): schemaDown {
    return {
      schema: `${schemaName !== 'public' ? 'DROP SCHEMA "' + schemaName + '"' : ''
        }`,
      tables: tables
        .map((tableName) => {
          return `DROP TABLE IF EXISTS "${schemaName}"."${tableName}" CASCADE;`
        })
        .toString()
        .replace(/,/g, '')
        .replace(/(\\)|(,\s)/g, ',')
    }
  }
}

