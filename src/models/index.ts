import { DB as DBA } from '@elumian/db'
import type {
  options as optionsType,
  returnRef,
  typeRef,
  tablesRef,
  retrunVarchar,
} from '../type'

export const DataType: optionsType = {
  varchar: (length: number = 255): retrunVarchar => {
    return `varchar(${length})`
  },
  smallInt: 'SMALLINT',
  bigInt: 'BIGINT',
  text: 'TEXT',
  pk: 'PRIMARY KEY',
  increment: 'GENERATED BY DEFAULT AS IDENTITY',
  unique: 'UNIQUE',
  notNull: 'NOT NULL',
  boolean: 'BOOLEAN',
  bool: 'BOOL',
  timeStamp: 'TIMESTAMP',
  ref: (type: typeRef, tables: tablesRef): returnRef => {
    const [schema, table, column] = tables.split('.') as [
      string,
      string,
      string
    ]

    switch (type) {
      case '>':
        return `ALTER TABLE "<schemaRef>"."<tableRef>" ADD FOREIGN KEY ("<columnRef>") REFERENCES "${schema}"."${table}" ("${column}");`
      case '<':
        return `ALTER TABLE "${schema}"."${table}"  ADD FOREIGN KEY ("${column}") REFERENCES "<schemaRef>"."<tableRef>" ("<columnRef>");`
      case '-':
        return `ALTER TABLE "<schemaRef>"."<tableRef>" ADD FOREIGN KEY ("<columnRef>") REFERENCES "${schema}"."${table}" ("${column}");`
      default:
        return ''
    }
  },
}

export class Model {
  protected schemaName: string = 'public'
  protected tableName: string = 'test'
  public DB: any
  protected exclude: string[] = ['id', 'create_at', 'update_at']
  protected columns: string[]

  constructor(schemaName: string, tableName: string) {
    this.schemaName = schemaName
    this.tableName = tableName
    this.init()
  }

  protected async init(): Promise<void> {
    this.DB = new DBA(this.schemaName, this.tableName)
    await this.DB.queryExec(
      `select column_name  from information_schema.columns
where table_schema = '${this.schemaName}' and table_name = '${this.tableName}'`
    )
      .then((res: any) => {
        this.columns = res.rows.filter((v: string) => !this.exclude.includes(v))
      })
      .catch((e: any) => {
        console.log(e)
      })
  }

  async findAll(): Promise<Array<Record<any, string>>> {
    const result = await this.DB.select(this.columns).get()
    return result.rows
  }

  async findOne(
    whereOptions: {
      fields: string | string[]
      option: 'AND' | 'OR'
    } | null = null
  ): Promise<Record<any, any>> {
    let result: Promise<any>
    if (whereOptions === null)
      result = await this.DB.select(this.columns).exec().rows[0]
    else
      result = await this.DB.select(this.columns)
        .where(whereOptions.fields, whereOptions.option)
        .get().rows[0]

    return await result
  }

  async count(): Promise<number> {
    const result = await this.DB.select('count(*) as count').get()
    return result.rows[0].count
  }
}
