import type {
  schemaTables,
  options as optionsType,
  retrunVarchar,
  schemaUp,
  schemaDown,
  returnRef,
  typeRef,
  tablesRef,
  columnsPropiety,
  schemaFunctions,
  schemaProcedure,
  procedureFields,
  functionsFields,
} from '../type'

export const options: optionsType = {
  varchar: (length: number = 255): retrunVarchar => {
    return `varchar(${length})`
  },
  smallInt: 'SMALLINT',
  bigInt: 'BIGINT',
  text: 'TEXT',
  pk: 'PRIMARY KEY',
  increment: 'GENERATED BY DEFAULT AS IDENTITY',
  unique: 'UNIQUE',
  notNull: 'NOT NULL',
  boolean: 'BOOLEAN',
  bool: 'BOOL',
  timeStamp: 'TIMESTAMP',
  ref: (type: typeRef, tables: tablesRef): returnRef => {
    const [schema, table, column] = tables.split('.') as [
      string,
      string,
      string
    ]

    switch (type) {
      case '>':
        return `ALTER TABLE "<schemaRef>"."<tableRef>" ADD FOREIGN KEY ("<columnRef>") REFERENCES "${schema}"."${table}" ("${column}");`
      case '<':
        return `ALTER TABLE "${schema}"."${table}"  ADD FOREIGN KEY ("${column}") REFERENCES "<schemaRef>"."<tableRef>" ("<columnRef>");`
      case '-':
        return `ALTER TABLE "<schemaRef>"."<tableRef>" ADD FOREIGN KEY ("<columnRef>") REFERENCES "${schema}"."${table}" ("${column}");`
      default:
        return ''
    }
  },
}

export class Schema {
  private makeProceduresQuery(
    schemaName: string,
    procedures: schemaProcedure = null
  ): string {
    if (procedures == null) return ''
    const procedureName: string[] = Object.keys(procedures)
    return procedureName
      .map((v: string) => {
        const procedure: procedureFields | null = procedures[v] ?? null
        if (procedure == null) return ''

        let parametersKeyIn: string[] = []
        let parametersKeyOut: string[] = []
        let parametersKey
        let declareKey

        const fieldsIn: Record<string, string> = procedure.parameters.in
        const fieldsOut: Record<string, string> | undefined =
          procedure.parameters.out
        parametersKeyIn = Object.keys(fieldsIn)

        parametersKey = parametersKeyIn.map((z) => {
          const field: string | null = fieldsIn[z] ?? null
          if (field == null) return ''
          return `${z}#23${field.replace(/\s/g, '#23')}`
        })
        if (fieldsOut != null) {
          parametersKeyOut = Object.keys(fieldsOut)
          parametersKey = [
            ...parametersKey,
            ...parametersKeyOut.map((z) => {
              const field: string | null = fieldsOut[z] ?? null
              if (field == null) return ''
              return `${z}#23${field.replace(/\s/g, '#23')}`
            }),
          ]
        }
        const declares: Record<string, string> | undefined = procedure.declare
        if (declares != null) {
          declareKey = Object.keys(declares)
          declareKey = declareKey.map((z) => {
            const declare: string | null = declares[z] ?? null
            if (declare == null) return ''
            return z + '#23' + declare.replace(/\s/g, '#23') + ';'
          })
        }
        const result = `
          create#23or#23replace#23procedure#23"${schemaName}"."${v}"(${parametersKey
          .toString()
          .replace(/,/g, '#24')})
          #23language#23plpgsql
          #23as#23$$#23
          #23declare#23
          ${declareKey != null ? declareKey.toString() : ''}
          #23begin#23
          ${procedure.comantBlock
            .replace(/(\s)\1/g, '#23')
            .replace(/\s/g, '#23')
            .replace(/,/g, '#24')}
          end;#23$$;
          `
        return result.replace(/(#23)/g, ' ')
      })
      .toString()
      .replace(/,/g, '')
      .replace(/(#24)/g, ',')
  }

  private makeFunctionsQuery(
    schemaName: string,
    functions: schemaFunctions
  ): string {
    if (functions == null) return ''
    const functionsName = Object.keys(functions)
    return functionsName
      .map((v) => {
        let parametersKey: string[] = []
        let declareKey
        const functionOne: functionsFields | null = functions[v] ?? null
        if (functionOne == null) return ''
        const parameters: Record<string, string> | null =
          functionOne.parameters ?? null
        parametersKey = Object.keys(functionOne.parameters)
        parametersKey = parametersKey.map((z) => {
          const parameter: string | null = parameters[z] ?? null
          if (parameter == null) return ''
          return `${z}#23${parameter.replace(/\s/g, '#23')}`
        })
        const declares: Record<string, string> | null =
          functionOne.declare ?? null
        if (declares != null) {
          declareKey = Object.keys(declares)
          declareKey = declareKey.map((z) => {
            const declare: string | null = declares[z] ?? null
            if (declare == null) return ''
            return z + '#23' + declare.replace(/\s/g, '#23') + ';#23'
          })
        }
        const result = `
          create#23or#23replace#23function#23"${schemaName}"."${v}"(${parametersKey
          .toString()
          .replace(/,/g, '#24')})#23
          Returns#23${functionOne.return}#23
          #23language#23plpgsql
          #23as#23$$#23
          #23declare#23
          ${declareKey != null ? declareKey.toString() : ''}
          #23begin#23
          ${functionOne.comantBlock
            .replace(/(\s)\1/g, '#23')
            .replace(/\s/g, '#23')
            .replace(/,/g, '#24')}
          end;#23$$;

          `
        return result.replace(/(#23)/g, ' ')
      })
      .toString()
      .replace(/,/g, '')
      .replace(/(#24)/g, ',')
  }

  private makeTablesQuery(
    schemaName: string,
    tables: schemaTables,
    ref: string[]
  ): string {
    const tablesName: string[] = Object.keys(tables)
    return tablesName
      .map((key) => {
        const table: Record<string, columnsPropiety[]> | null =
          tables[key] ?? null
        if (table == null) return ''
        const columnsName: string[] = Object.keys(table)
        const columns: string = columnsName
          .map((name) => {
            let parameters: columnsPropiety[] | null = table[name] ?? null
            if (parameters == null) return ''
            if (
              parameters.filter((v) => v.includes('ALTER TABLE ')).length > 0
            ) {
              ref.push(
                parameters
                  .filter((v) => v.includes('ALTER TABLE '))
                  .map((v) => {
                    return v
                      .replace(/<schemaRef>/g, schemaName)
                      .replace(/<tableRef>/g, key)
                      .replace(/<columnRef>/g, name)
                  })
                  .toString()
              )
            }
            parameters = parameters.filter((v) => !v.includes('ALTER TABLE'))
            return `"${name}" ${parameters.toString().replace(/,/g, ' ')}\\`
          })
          .toString()
          .replace(/,/g, '\n')
        return `CREATE TABLE IF NOT EXISTS "${schemaName}"."${key}" (
      ${columns}
      "created_at" timestamp default 'now()'\\
      "updated_at" timestamp default 'now()'
      );`
      })
      .toString()
      .replace(/,/g, '')
      .replace(/(\\)|(,\s)/g, ',')
  }

  public create(
    schemaName: string,
    tables: schemaTables,
    procedures: schemaProcedure = null,
    functions: schemaFunctions = null
  ): schemaUp {
    const ref: string[] = []

    const query = {
      schema: `CREATE SCHEMA IF NOT EXISTS "${schemaName}";`,
      tables: `${this.makeTablesQuery(schemaName, tables, ref)}`.replace(
        /(\s{2,})/g,
        ''
      ),
      ref: ref.toString().replace(/,/g, ''),
      procedures: this.makeProceduresQuery(schemaName, procedures),
      functions: this.makeFunctionsQuery(schemaName, functions),
    }
    return query
  }

  public drop(schemaName: string, tables: string[]): schemaDown {
    return {
      schema: `${
        schemaName !== 'public'
          ? 'DROP SCHEMA "' + schemaName + '" CASCADE;'
          : ''
      }`,
      tables: tables
        .map((tableName) => {
          return `DROP TABLE IF EXISTS "${schemaName}"."${tableName}" CASCADE;`
        })
        .toString()
        .replace(/,/g, '')
        .replace(/(\\)|(,\s)/g, ','),
    }
  }
}
